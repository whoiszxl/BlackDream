## 以太坊源码分析环境搭建

### 以太坊源码安装
1. 通过命令下载以太坊源码：`go get github.com/ethereum/go-ethereum`
2. 然后通过GOLAND打开`go-ethereum/rlp/decode_test.go`文件运行测试是否环境搭建成功
3. 如果没有gcc，需要下载安装:`http://tdm-gcc.tdragon.net/download`


### 以太坊源码go-ethereum基础目录介绍
```
accounts		实现了一个高等级的以太坊账户管理
bmt				二进制的默克尔树的实现
build			主要是编译和构建的一些脚本和配置
cmd				命令行工具，又分了很多的命令行工具
	/abigen		Source code generator to convert Ethereum contract definitions into easy to use, compile-time 
type-safe Go packages
	/bootnode	启动一个仅仅实现网络发现的节点
	/evm		以太坊虚拟机的开发工具， 用来提供一个可配置的，受隔离的代码调试环境
	/faucet		
	/geth		以太坊命令行客户端，最重要的一个工具
	/p2psim		提供了一个工具来模拟http的API
	/puppeth	创建一个新的以太坊网络的向导
	/rlpdump 	提供了一个RLP数据的格式化输出
	/swarm		swarm网络的接入点
	/util		提供了一些公共的工具
	/wnode		这是一个简单的Whisper节点。 它可以用作独立的引导节点。此外，可以用于不同的测试和诊断目的。
common			提供了一些公共的工具类
compression		Package rle implements the run-length encoding used for Ethereum data.
consensus		提供了以太坊的一些共识算法，比如ethhash, clique(proof-of-authority)
console			console类
contracts	
core			以太坊的核心数据结构和算法(虚拟机，状态，区块链，布隆过滤器)
crypto			加密和hash算法，
eth			实现了以太坊的协议
ethclient		提供了以太坊的RPC客户端
ethdb			eth的数据库(包括实际使用的leveldb和供测试使用的内存数据库)
ethstats		提供网络状态的报告
event			处理实时的事件
les			实现了以太坊的轻量级协议子集
light			实现为以太坊轻量级客户端提供按需检索的功能
log			提供对人机都友好的日志信息
metrics			提供磁盘计数器
miner			提供以太坊的区块创建和挖矿
mobile			移动端使用的一些warpper
node			以太坊的多种类型的节点
p2p			以太坊p2p网络协议
rlp			以太坊序列化处理
rpc			远程方法调用
swarm			swarm网络处理
tests			测试
trie			以太坊重要的数据结构Package trie implements Merkle Patricia Tries.
whisper			提供了whisper节点的协议。
```

### 以太坊项目模型
> 从底层到上层分别为：

1. 数据层：存储区块等信息，leveldb键值对存储
2. 网络层：P2P网络，Kademlia（kad）网络，kad网络是一种本身节点查找临近节点的算法，通过UDP广播，NAT实现路由器穿透
3. 共识层：以太坊和比特币一样采用`POW(proof of work)`工作量证明机制，但以太坊有向POS转变的趋势，但是难度极大
4. 激励层：POW挖矿奖励激励
5. 合约层：合约层可开发DAPP，这部分包括了坊虚拟机EVM和智能合约。
6. 应用层：以太坊显示层，以太坊使用truffle和web3js技术，DAPP和代币发行都在这一层


### 搭建最简单的以太坊开发环境

#### 1. 创建创世区块：创建a,b两个文件夹，写入genesis.json
```json
{
    "config": {
        "chainId": 15,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    },
    "coinbase": "0x0000000000000000000000000000000000000000",
    "difficulty": "0x40000",
    "extraData": "",
    "gasLimit": "0xffffffff",
    "nonce": "0x0000000000000042",
    "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "timestamp": "0x00",
    "alloc": {}
}
```

#### 2. 进入目录下执行命令初始化
```shell
geth --datadir ./data-init1/ init genesis.json
geth --datadir ./data-init2/ init genesis.json
```

#### 3. 通过控制台启动节点
```shell
geth --datadir ./data-init1/ --networkid 88 --nodiscover console
geth --datadir ./data-init2/ --port 30306 --networkid 88 --nodiscover console #无效的时候需要加一个--ipcdisable参数
```

#### 4. 基础命令
1. 查看节点账户：`personal.listAccounts`
2. 创建账户：`personal.newAccount("123456")`
3. 查看coinbase：`eth.coinbase`
4. 查看账户详细信息：`personal.listWallets`
5. 查看连接的节点：`admin.peers`
6. 查看enode的信息：`admin.nodeInfo.enode`
7. 添加节点：`admin.addPeer("enode://xxxxxx")`
8. 查看余额：`eth.getBalance(eth.coinbase)`
9. 执行挖矿：`miner.start()`
10. 停止挖矿：`miner.stop()`
11. 解锁账户：`personal.unlockAccount("xxxxx")`
12. 发送交易：`eth.sendTransaction({from:'xxxxx', to:'vvvvvvv', value:100000000})`


### 运行智能合约

#### 1.编写测试合约
```javascript
pragma solidity ^0.4.26;

contract Sample {
    uint public value;
    
    constructor(uint v) public {
        value = v;
    }
    
    function set(uint v) public {
        value = v;
    }
    
    function get() public view returns (uint) {
        return value;
    }
}
//https://remix.ethereum.org remix编译器
```

#### 2.获取到abi和二进制代码
```abi
[{"constant":true,"inputs":[],"name":"value","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"v","type":"uint256"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"v","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]
```

```bytecode
"608060405234801561001057600080fd5b506040516020806101618339810180604052810190808051906020019092919050505080600081905550506101178061004a6000396000f3006080604052600436106053576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633fa4f24514605857806360fe47b11460805780636d4ce63c1460aa575b600080fd5b348015606357600080fd5b50606a60d2565b6040518082815260200191505060405180910390f35b348015608b57600080fd5b5060a86004803603810190808035906020019092919050505060d8565b005b34801560b557600080fd5b5060bc60e2565b6040518082815260200191505060405180910390f35b60005481565b8060008190555050565b600080549050905600a165627a7a72305820d4d8a98c5afb9648cf4c1b40853767fbecd5c44e0a3fe85ae5ec38c3e51848910029"

# 使用时需要在前面加0x
```

#### 3.部署到链
```js
abi = "abi json";
sample=eth.contract(abi);
SampleHEX="bytecode";
thesample=sample.new(1,{from:eth.accounts[0],data:SampleHEX,gas:3000000});
```

#### 4.挖矿一段时间打包好区块然后查看交易细节拿到合约地址
```shell
miner.start();
miner.stop();
samplerecpt=eth.getTransactionReceipt("thesample中的txhash")
```

#### 5.合约命名并调用
```shell
samplecontract=sample.at("合约地址")
samplecontract.get.call()
samplecontract.set.sendTransaction(9, {from:eth.accounts[0], gas:3000000})

# 挖矿后打包了区块 智能合约才能运作
miner.start()
miner.stop()

samplecontract.get.call()
```

#### 6.使用另一个节点at到合约地址也可以调用
```shell
abi=[{"constant":true,"inputs":[],"name":"value","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"v","type":"uint256"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"v","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]
sample=eth.contract(abi)
samplecontract=sample.at("合约地址")
samplecontract.get.call()
```